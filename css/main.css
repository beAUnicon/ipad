/* 공통영역 css */
html {
  --color-white: #fff;
  --color-black:#000;
  --color-font:#1D1D1D;
  --color-font-darkgray:#6E6E6E;
  --color-font-middlegray: #B7B7B7;
  --color-font-lightgray:#F5F5F5;
  --color-link:#0071E3;
  --color-link-focus:#81B9F1;
  --color-border:#D2D2D2;
  --color-header:#3A3A3A;
  --color-section:#F5F5F5;
  --color-shadow:rgba(0,0,0,0.4);
}
html.fixed {
  position:fixed;
  overflow-y: scroll;
  width:100%;
}
body {
  font-family: "Roboto", "Noto Sans KR", sans-serif;
  line-height:1;
  font-size:16px;
  word-break:keep-all;
  color:var(--color-font); 
  height:10000px;
}
a {
  color:var(--color-font);
  text-decoration: none;
}
img {
  display:block;
  user-select:none;
  -webkit-user-drag: none;
}
p {
  line-height:1.6;
}
sup {
  margin-right:6px;
  font-size:.7em;
  vertical-align: top;/* 윗첨자글자이므로 수직정렬을 위쪽으로 해준다. */
}

/* Inner */
.inner {
  max-width: 980px;
  margin: 0 auto;
  padding: 0 20px;
  position:relative; /* 앞으로 생길 많은 inner의 후손 요소들이 absolute로 사용될수있도록 미리 position값을 넣어둠 */
}
/* 미디어에선 다르게 작동하거나 배치되는 특성을 미리 선언 */
@media (max-width: 1000px) {
  .inner {
    max-width:692px;
  }
}

/* Btn */
.btn {
  display:flex;
  justify-content:center;
  align-items:center;
  height:24px;
  padding:0 10px;
  border:none;
  border-radius:100px;
  outline:none;
  font-size:11px;
  line-height:1;
  color:var(--color-white);
  background-color:var(--color-link);
  cursor:pointer;

}
.btn:hover {
  opacity:0.7;
}
.btn:focus { /* 이렇게 구현하는 이유는 outline이라는 속성보다 제어하기 더 편하고 요소의 레이아웃에 영향을 주지 않기 때문임 그리고 그림자 부분을 블러처리 하지 않아서 마치 선처럼 보이게 하여 처리하는 것임 */
  box-shadow: 0 0 0 4px var(--color-link-focus);
}

/* Background image text */
.bgtext {
  display:block;
  text-indent: -9999px;
  background-position:center;
  background-repeat:no-repeat;
  background-size:contain;
}

/* Links */
.links { /* 두개가 있을때 사용하는 클래스로 개별적인 꺽쇠라던지 그런거는 link 클래스에 만들어두고 두개 이상일때의 각 링크들 사이의 공간이나 배열등을 설정해 주기 위해서 links를 사용함 추가적인 이유로 앞으로 두개의 링크를 사용하는 경우가 있는데 그때마다 사이의 공간과 배열이 다르면 안되므로 정해놓고 일정하게 배열이 되도록함 div로 묶고 해당 div에 links 클래스를 줘서 두개의 사이의 공간이나 배열들을 사용한다. */
  display:flex;
  justify-content:center;
  gap:40px;
}
a.link { /* 한개일때 사용하는 클래스 */
  color:var(--color-link);
  font-size:19px;
  line-height:1.3;
}
a.link:hover {
  text-decoration:underline;
}
a.link::after {
  content:" >"; /* 애초에 꺽쇠를 그냥 사용하는 곳마다 주면 안되나 싶지만 그래도 된다. 당연히.. 그러나 사용성을 위하여 사살싱 모듈화를 시켜놓고 반복적인 꺽쇠를 사용하는 아이들이 클래스만 사용해서 쉽게 사용할수있도록 하기 위해서 이렇게 하는 것이다. */
}

/* 미디어에선 다르게 작동하거나 배치되는 특성을 미리 선언 */
@media (max-width: 740px) {
  .links {
    flex-direction: column;
    align-items:center;
    gap:16px;
  }
  a.link {
    font-size:17px;
  }
}

/* Feature */
.feature {
  display:flex;
}

@media (max-width: 740px) {
  .feature {
    flex-direction:column;

  }
}

/* Figures */
.figures {
  flex-grow:1;
  position:relative;
}
.figures figure,
.figures figcaption {
  position:absolute; /* 이와 같이 포지션을 absolute로 하고 왼쪽 위로 정렬시킨다음에 각각의 피규어에 맞게 따로 translate로 이동시키는 이유는 relative라면 중간에 요소가 생기거나 기존 요소가 사라지면 구조가 무너지게 되므로 영향을 받지 않도록 absolute로 하고 같은 곳에서 필요한 만큼만 이동하도록 전부 같은곳에서 시작하도록 top:0; left:0;을 준다.그리고 이상태에서 transform의 translate로 위치이동을 시키면 요소들이 사라지거나 추가되더라도 각각의 요소들은 절대적인 위치를 잡고있는것이므로 구조가 무너지지 않음 */
  top:0;
  left:0;
}
.figures figcaption * {
  position:absolute;
  top:0;
  left:0;
} 

@media (max-width:740px) { /* 이 값이 필요한 곳마다 한번씩 써주면 되는데 굳이 여기다가 쓰는이유는 계속 같은 값을 사용해야 하는데 그냥 한번을 선언해두고 차이점이 있다면 차이점만 밑에서 각각 선언해서 쓰는것이 훨씬더 효율적이기 때문. */
  .figures {
    display:flex;
    justify-content:center;
  }
  .figures figure {
    position:relative;
  }
}
/* Infos */
.infos{
  display:flex;
  flex-direction:column;
  position:relative; /* 인포이미지가 피규어에 가려 잘리는 문제를 position을 주고 z-index값을 줘서 해결 */
  z-index:1;
}
.infos.infos--center {
  justify-content: center;
}
.infos.infos--end {
  justify-content: flex-end;
}
.info {
  max-width:330px;
  margin-bottom:24px;
  transition:1s;
  transform:translate(0, 100px);
  opacity:0;
}
.info.show {
  transform: translate(0, 0);
  opacity:1;
}
.infos--large .info {
  max-width:410px;
}
.info .icon {
  width:100px;
  height:100px;
  margin:0 0 -15px -30px;/* 한변의 길이가 100px인 정사각형 모양의 영역이 생길텐데 이때 아이콘이 훨씬 작아서 영역안에 빈공간이 생기므로 아래의 글과 너무 떨어져보여서 아래로 -15px을 주어 조금더 붙여주었고 같은 이유로 왼쪽에도 너무 떨어져보이면 줄이 안맞는것 같으므로 -30px을 해서 당김 */
  animation:sprite-icon 3s steps(1) infinite;
}
.info .icon.icon--chip         { background-image: url("../images/sprite_chip.png"); }
.info .icon.icon--faster       { background-image: url("../images/sprite_faster.png"); }
.info .icon.icon--neural       { background-image: url("../images/sprite_neural.png"); }
.info .icon.icon--apps         { background-image: url("../images/sprite_apps.png"); }
.info .icon.icon--battery      { background-image: url("../images/sprite_battery.png"); }
.info .icon.icon--display      { background-image: url("../images/sprite_display.png"); }
.info .icon.icon--true-tone    { background-image: url("../images/sprite_true_tone.png"); }
.info .icon.icon--center-stage { background-image: url("../images/sprite_center_stage.png"); }
.info .icon.icon--front-camera { background-image: url("../images/sprite_front_camera.png"); }
.info .icon.icon--back-camera  { background-image: url("../images/sprite_back_camera.png"); }
.info .icon.icon--scan         { background-image: url("../images/sprite_scan.png"); }
.info .icon.icon--download     { background-image: url("../images/sprite_download.png"); }
.info .icon.icon--wifi         { background-image: url("../images/sprite_wifi.png"); }
.info .icon.icon--lte          { background-image: url("../images/sprite_lte.png"); }
.info .icon.icon--pencil       { background-image: url("../images/sprite_pencil.png"); }
.info .icon.icon--keyboard     { background-image: url("../images/sprite_keyboard.png"); }
.info .icon.icon--notes        { background-image: url("../images/sprite_notes.png"); }
.info .icon.icon--covers       { background-image: url("../images/sprite_covers.png"); }
.info p {
  font-size:21.5px;
  font-weight:600;
  line-height:1.5;
}
.info a.link { /* 인포안에 있는 link 버튼의 배열등을 조정하려고 만든곳 */
  display:block; /* 위아래로 여백을 주려면 display가 inline이면 안됨 */
  margin-top:44px;/* 위에 위치할 info와 너무 딱붙어있어서 위쪽 여백을 줌 */
  font-size:19.5px;
}

@media (max-width:1000px) {
  .info {
    max-width:230px;
  }
  .infos--large .info {
    max-width: 288px;
  }
  .info .icon {
    transform: scale(0.8);
    margin: -30px 0 -24px -32px;
  }
  .info p {
    font-size:19px;
    line-height:1.4;
  }
  .info a.link {
    margin-top:24px;
  }
}

@media (max-width:740px) {
  .info {
    max-width: none;
    padding: 0 20px;
  }
  .infos--large .info {
    max-width:none;
  }
  .info a.link {
    font-size: 17px;
  }
}
/* Whitebox  */
.whitebox {
  max-width:1386px;
  margin:0 auto;
  padding:100px 30px;
  border-radius: 30px;
  box-sizing: border-box;
  background-color:var(--color-white);
}
.whitebox.whitebox--transparent {
  background-color:transparent;
}
.whitebox .icon {
  margin-bottom:20px;
}
.whitebox h1 {
  font-size:50px;
  font-weight:600;
  line-height:1.3;
}
.whitebox p {
  margin-top:20px;
  font-size:19px;
}
.whitebox a.link {
  display:block;
  margin-top:26px;
}
@media (max-width: 1000px) {
  .whitebox {
    padding: 60px 30px;
  }
  .whitebox .icon {
    width: 44px;
  }
  .whitebox h1 {
    font-size: 36px;
  }
}
@media (max-width:740px) {
  .whitebox p {
    font-size: 17px;
  }
}

/* Header */
header {
  --header-height:44px; /* 높이값을 변수로 저장하는 이유는 header의 height인 44px에 맞춰서 다들 44px의 값을 가지고 있는데 만약 44px보다 값이 늘어나거나 줄어들면 맞춰서 값을 전부다 하나 하나 바꿔줘야 하기대문에 변수로 저장해서 값이 변하더라도 직접 하나 하나 변경할 필요없게 만듦 */
  background-color:var(--color-header);
  position:relative;
  z-index:9;
  transition:0.4s;
}
header .inner {
  max-width:1020px; /* width를 지정하지 않는다면 요소의 width값은 안의 콘텐츠들의 width값만큼을 가짐
                      그러나 max-width가 있다면 커지다가도 max-width값에 다다르면 더이상 콘텐츠
                      즉 요소의 width가 커질수없음을 뜻함 그러나 width값이 줄어드는 것은 계속 해서 줄어들수있음
                      다시 말해 화면을 아무리 광활하게 만들어줘도 넓어지는 넓이에 맞춰
                      늘어나는 것이 아니라 1020의 여유공간이 나올때까지 늘어나다가
                      화면이 그이상으로 늘어난다면 1020초과로 늘어날수없고
                      화면을 엄청나게 줄이면 줄이는 대로 계속 해서 맞춰 줄어든다.
                       */

  /* box-sizing:border-box;
  border: 2px solid blue; */
}
header ul.menu {
  height:var(--header-height);
  display:flex;
  justify-content:space-between;
}
header ul.menu > li {
  display:flex;
  position:relative;
  transition: 0.4s;
                         /* 여기서 flex-item들이 기본적으로 align stretch 된다는 것을 이용하여 자식인
                            a의 영역을 li의 영역 만큼으로 늘어나도록 align-items의 값을 넣지 않음 여기서
                            align-items의 값을 center로 넣으면 a자체가 li안에서 중앙으로 움직이겠지만
                            stretch값을 못받으므로 위아래 여백이 생기고 해당 영역은 클릭해도 아무일도일어
                            나지 않음 
                            간단히 말해 li에 display를 flex로 준이유는 a를 stretch로 영역전체를 자치하도록
                            하기 위해서이고 a에 display를 flex로 준이유는 a안의 값을 a안의 가운데로 정렬하도록
                            한것임.*/
}
header ul.menu > li.menu-starter {
  display:none;
  cursor:pointer;
}

header ul.menu > li > a{
  padding:0 10px;
  font-size:11px;
  display:flex;
  align-items:center;
  color:var(--color-font-lightgray);
  opacity:0.8;
  text-decoration:none;
                           /* 위에서 a의 영역을 li영역만큼으로 늘렸으므로 a안의 요소를 부모인
                              요소의 가운로 정렬을 할수있도록 a에 display를 flex로 줌 */

}

header ul.menu > li.apple-logo > a,
header ul.menu > li.search-starter > a,
header ul.menu > li.basket-starter > a{
  width:14px;
  text-indent:-9999px;
  background-repeat:no-repeat;
  background-position:center 13px;
}
header ul.menu > li.apple-logo > a {
  background-image: url("../images/header_apple.svg");
}
header ul.menu > li.search-starter > a {
  background-image: url("../images/header_search.svg");
}
header ul.menu > li.basket-starter > a {
  background-image: url("../images/header_bag.svg");
}

header ul.menu > li >  a:hover {
  opacity:1;
}
/* Header / Menu / Basket */
header .basket {/* 장바구니 드롭다운 메뉴영역 */
  width:290px;
  padding:10px 20px;
  border: 1px solid var(--color-border);
  border-radius:10px;
  box-sizing:border-box;
  background-color:var(--color-white);
  position:absolute;
  top:calc(100% + 4px);
  right:-6px;
  visibility:hidden;
  transition:0.4s;
  opacity:0;
}
header .basket.show {
  visibility: visible;
  opacity:1; /* 비저블리티와 항상 같이 사용함을 주의! 이걸빼면 효과가 이상해짐 */
}
header .basket .arrow {
  width:20px;
  height:10px;
  position:absolute;
  top:-10px;
  right:12px;
  overflow:hidden;
}
header .basket .arrow::before {
  content:"";
  width:12px;
  height:12px;
  border: 1px solid var(--color-border);
  background-color: var(--color-white);
  transform: rotate(45deg);
  transform-origin:0 0;
  position:absolute;
  top:0;
  left:50%;
}
header .basket .message {
  padding:30px 0;
  font-size:13px;
  color:var(--color-font-darkgray);
  text-align:center;
}
header .basket ul {
  margin-top:10px;

}
header .basket ul li {
  border-top:1px solid var(--color-border);
}
header .basket ul li a {
  display:block;
  font-size: 13px;
  color:var(--color-link);
  padding:14px;
}
header .basket ul li a:hover {
  text-decoration:underline;
}

/* Header / Search */
header .search-wrap {
  position:absolute;
  top:0;
  left:0;
  width:100%;
  visibility:hidden;
  opacity:0;
  transition:0.4s;
}
header .search {
  max-width:680px;
  margin:0 auto;
  position:relative;
}
header .search .shadow {
  position:fixed; /* 뷰포트를 기준으로 위치함 아래에서 width 100%, height 100%를 해줌으로써 전체 뷰포트를 기준으로 100% 그러니까 전체 html문저 전체를 대상으로 하는 것 */
  top:0;
  left:0;
  width:100%;
  height:100%;
  background-color:var(--color-shadow);
}
header .search .textfield {
  position:relative;
}
header .search input {
  width:100%;
  height:var(--header-height);
  padding:0 40px;
  border:none;
  outline:none;
  box-sizing:border-box;
  background-color:transparent; /* 투명한색을 의미 */
  font-size:17px;
  color: var(--color-white);
}
header .search .search-icon {
  width: 40px;
  height:var(--header-height);
  background-image: url("../images/header_search.svg");
  background-repeat:no-repeat;
  background-position:center;
  position:absolute;
  top:0;
  left:0;
  opacity:0.4;
}
header .search .search-closer {
  width: 40px;
  height:var(--header-height);
  background-image: url("../images/header_close.svg");
  background-repeat:no-repeat;
  background-position:center;
  position:absolute;
  top:0;
  right:0;
  opacity:0.4;
  cursor:pointer;
}
header .search .search-closer:hover {
  opacity:1;
}
header .search .autocompletes {
  width:100%;
  padding:26px 40px 20px;
  border-radius:0 0 18px 18px;
  /* border:1px solid red; */
  box-sizing:border-box;
  background-color:var(--color-white);
  position:absolute;
  top: var(--header-height);
  left:0;
}
header .search .autocompletes h3 {
  font-size:12px;
  color:var(--color-font-darkgray);
  margin-bottom:12px;
}

header .search .autocompletes ul li a {
  display:block; /* 애초에 inline요소는 글자 요소로 옆에 요소들이 존재할수있도록 만든 요소이고 block요소는 한줄을 전부 차지하도록 혹은 width값과 height값을 초기화 하여 원하는 크기로 조절하고 한줄에 한 요소인 만큼 요소의 사이간의(세로) 설정을 하기위해선 block으로 해야 한다. 왜냐면 요소의 사이(세로)의 공간을 조정하고 관리하는건 원래 block이 하는 것이므로.. inline은 반면에 block보다 한줄에 있는 글자를 두껍게 한다거나 등의 역활을 하는것은 inline이 강력하다. */
  margin:0 -14px;
  padding:10px 0 10px 30px;
  font-size:14px;
  cursor:pointer;
}
header .search .autocompletes ul li:hover a {
  background-color:var(--color-section);
  color:var(--color-link);
}
header .clone-menu {
  display:none;
}

/* Search Animation */
/* 스타일을 한 번에 지정 */
header .search input,
header .search .search-icon,
header .search .autocompletes h3,
header .search .autocompletes li {
  transition: 0.95s;
  transform: translate(100px, 0);
}
header.searching ul.menu > li {
  transform: scale(0.7);
  opacity:0;;
}
header.searching .search-wrap {
  visibility:visible;
  opacity:1;
  transition-delay: 0.2s; /* 요소가 나타날때 위의 메뉴가 사라지고 그다음 0.2s후에 사라지게함 자연스럽게 사라지도록 하기 위함이고 없어지는건 한번에 없어져야 되니 여기에만 사용함 */



                /* display이외의 값들은 어떻게 다시 똑같이 써주지 않아도 동일하게 되냐? 사실 이건 상속되는 것이 아니라 우선순위 관계이기 때문이다. header와 header.search는 모두 header라는 요소를 칭하지만 우선순위는 header.search가 조건이 하나 더있어 높으므로 header.search에 작성된 display가 header에 작성된 display를 이겨 값이 바뀌고
                   나머지값들은 우선순위 비교할 대상이 없으니 결국은 header인 header.serach에도 적용이 되는것이다. */
}
header.searching .search input,
header.searching .search .search-icon,
header.searching .search .autocompletes h3,
header.searching .search .autocompletes li {
  transition-delay: 0.2s;
  transform: translate(0, 0);
}


@media (max-width:1000px) {
  header .inner {
    padding:0 10px;
  }
}
@media (max-width:740px) {
  header::before {
    content: "";
    position:fixed;
    top:var(--header-height);
    left: 0;
    width:100%;
    height:0;
    background-color: var(--color-header);
    transition:0.4s;

  }
  header ul.menu > li {
    display:none;
  }
  header ul.menu > li.menu-starter,
  header ul.menu > li.apple-logo,
  header ul.menu > li.basket-starter {
    display:flex; /* 원래 display가 flex인 아이들이였으므로 없앨땐 none이어도 다시 보이게 할땐 flex로 해줘야 한다. */
  }
  header ul.menu > li.menu-starter span {
    display:block;
    width: 15px;
    height:1px;
    background-color: var(--color-white);
    margin-bottom:6px;
    transition: 0.4s;
  } /* 갑자기 생긴 궁금증인 왜 ul.menu가 44px인데 어떻게 li도 44px을 height값으로 가지지?에 대한 답은 ul에서 display를 해서 li가 flex-item이 되었고 그로인해 stretch라는 성질에 의해 height값을 전부 차지 하게 된것이고 a도 li에 display가 flex여서 stretch가 된것이다. */
  header ul.menu >li.menu-starter span:last-child {
    margin-bottom:0;
  }
  header .search-wrap {
    padding: 0 20px 14px;
    border-bottom:1px solid var(--color-header);
    box-sizing:border-box;
    top: var(--header-height);
  }
  header .serach {
    max-width:590px;
  }
  header .shadow {
    display:none;
  }
  header .search .textfield {
    border-radius: 10px;
    background-color:#1D1D1D;
    width:100%;
    transition:0.2s; /* 가로폭이 줄어들었을때 애니메이션 처리가 되지 않는 이유는 원래의 textfield 즉 여기에 width값이 없기때문에 auto라는 값을 가지고 auto값에서 단위값으로 자연스럽게 바뀔수는 없기때문임 그래서 해결하기 위해 위에 100%라는 값을 줌(auto일때도 block이라 100%를 사용하고있었고 밑에서 100% - 55px) 처럼 퍼센트를 사용했으므로. */ 
  }
  header .search .search-closer {
    display:none;
  }
  header .search .search-canceler {
    height:var(--header-height);
    display:flex;
    align-items:center;
    padding:0 8px;
    color:var(--color-link);
    cursor:pointer;
    position:absolute;
    top:0;
    right:0;
    transition:0.4s;
    visibility:hidden;
    opacity:0;
  }
  header .search input,
  header .search .search-icon,
  header .search .autocompletes h3,
  header .search .autocompletes li {
    transform: translate(0, 0);
}
  header .search .autocompletes {
    top: 58px;
    padding:26px 0 20px;
    background-color: transparent;
    visibility:hidden;
    opacity:0;
    transition:0.3s; /* 입력란을 클릭했을때 자연스럽게 나오도록 함 */
    transform:translate(0, -100px); /* 원래는 안보이게 하다가 검색창을 눌렀을때 움직이면서 보이게 하기 위해서 다른 곳에 위치시켜둠 */
  }
  header .search .autocompletes ul li {
    border-bottom: 1px solid var(--color-header);
  }
  header .search .autocompletes ul li:last-child {
    border-bottom:none;
  }
  header .search .autocompletes ul li a {
    padding: 16px 0 16px 16px;
    color: var(--color-font-middlegray);
  }
  header .search .autocompletes ul li:hover a {
    background-color:transparent;
    color:var(--color-link)
  }
  header .clone-menu {
    display:block; /* 화면에는 보이는 상태이지만 애니메이션을 통해서 자연스럽게 나타나게 하기 위해서 visibility와 opacity를 사용 */
    visibility:hidden;
    opacity:0;
    position:absolute;
    top:103px;
    left:0;
    width:100%;
    padding:0 20px;
    box-sizing:border-box;
    transition:0.4s;
    transform:translate(0, -50px);
  }
  header .clone-menu ul {
    max-width:590px;
    margin : 4px auto;
  }
  header .clone-menu ul li {
    border-bottom:1px solid var(--color-header);
  }
  header .clone-menu ul li:last-child {
    border-bottom:none;
  }
  header .clone-menu ul li a {
    padding:16px 0;
    display:block;
    font-size: 14px;
    color:var(--color-font-middlegray);
  }
  header .clone-menu ul li:hover a{
    color:var(--color-white)
  }
  header.menuing {
    background-color: var(--color-black);
  }
  header.menuing::before { /* 버튼이 눌러졌을때는 원래 위에서 height:0으로 보이지 않게 해놨던 것이 height값이 100vh로 생기면서 보이게됨 */
    height:100vh;
    background-color: var(--color-black);
  }
  header.menuing ul.menu > li.basket-stater {
    opacity:0;
    visibility:0;
  }
  header.menuing ul.menu > li.menu-starter span:first-child {
    transform: translate(0, 3.5px) rotate(45deg); /* 아래로 3.5px 내려와서 45도 회전 */
  }
  header.menuing ul.menu > li.menu-starter span:last-child {
    transform: translate(0, -3.5px) rotate(-45deg);  /* 위로 3.5px 올라와서 -45도 회전 결과적으로 두개의 선이 겹쳐져서 x가 모양이 생기게됨*/
  }
  header.menuing .search-wrap {
    visibility:visible;
    opacity:1;
  }
  header.menuing .clone-menu {
    visibility:visible;
    opacity:1;
    transform:translate(0,0);
  }
  header.menuing.searching--mobile {
    transform: translate(0, -30px);
  }
  header.menuing.searching--mobile .search .textfield {
    width: calc(100% - 55px); /* 취소버튼이 오른쪽에 따로 있어야 하므로 취소버튼의 크기만큼 빼서 textfield를 줄여줌 그럼 뭐가 이상하게 될 가능성이 있지 않을까 싶지만 textfield는 relative로 줄어들어도 .search의 왼쪽위 즉 왼쪽에 딱 붙어있을 것이고 취소버튼은 absolute라 서로 이상하게 배열되지 않음. */
  }
  header.menuing.searching--mobile .search .autocompletes {
    visibility:visible;
    opacity:1;
    transform:translate(0,0);
    /* 왜 원래의 위치로 돌아왔는데 absolute인데도 위치상 부모인 search의 왼쪽 위에 있지 않고 마치 .textfield의 다음 형제요소처럼 있냐하면. top,left 등 위치값을 명시하지 않으면 html의 흐름대로 위치하기 때문임. 즉 .textfield 아래오게됨 */
  }
  header.menuing.searching--mobile .search .search-canceler {
    visibility:visible;
    opacity:1;
  }
  header.menuing.searching--mobile .clone-menu {
    visibility:hidden;
    opacity: 0;
    transform: translate(0, 100px);
  }
}

/* Navigation */
nav {
  --nav-height: 52px;
  background-color:rgba(255,255,255,0.7);
  backdrop-filter:blur(20px);
  border-bottom:1px solid var(--color-border);
  position:sticky;
  top:0;
  z-index:8;
}
nav .inner {
  max-width:1000px;
  height:var(--nav-height);
  display:flex;
  align-items:center
}
nav h1 {
  flex-grow:1;
  font-size:22px;
  font-weight:500;

}
nav .menu {
  display:flex;
  gap:12px;
  margin-right:18px;
}
nav .menu li {

}
nav .menu li a{
  display:block;
  font-size:11px;
  padding:6px;
}
nav .menu li a:hover {
  color:var(--color-link);

}
nav ul li.active a {
  opacity:0.5;
  cursor:default;
}
nav ul li.active a:hover {
  color:var(--color-font); /* 위에서 a에 hover했을때 파란색이 되도록 했었는데 해당 부분은 색이 변하면 안되므로 원래의 글자색을 가져와서 설정해준다. */
}

@media (max-width:740px) {
  nav .shadow { /* menuing이 되었을때 즉 토글을 클릭하여 메뉴를 볼때 그림자 처리를 하기 위해서 세팅함 */
    position:fixed;
    top: 0;
    left: 0;
    width:100%;
    height:100vh;
    background-color:var(--color-shadow);
    visibility: hidden;
    opacity: 0;
    transition: 0.4s;
  }
  nav .contents-bg {
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:var(--nav-height);
    border-bottom:1px solid var(--color-border);
    background-color:var(--color-white);
    visibility:hidden;
    transition: 0.4s;
  }
  nav .menu-toggler {
    width:30px;
    height:14px;
    margin-right:10px;
    cursor:pointer;
    position:relative;/* toggler가 지금 약간 이상한 위치에 배치가 되는것은 menu를 안보이게 했지만 안에있기때문이다. position이 relative이기 때문. */
  }
  nav .menu-toggler::before,
  nav .menu-toggler::after {
    content: "";
    display:block;
    width:11px;
    height:1px;
    background-color:var(--color-font-darkgray); /* 배경색상 */
    position:absolute;
    top:0;
    bottom:0;
    left:0;
    right:0;
    margin: auto;
    transition: 0.4s; 
  }
  nav .menu-toggler::before {
    transform: rotate(40deg);
    left:-9px;
  }
  nav .menu-toggler::after {
    transform:rotate(-40deg);
    right:-9px;
  }
  nav .menu {
    position:absolute;
    top:var(--nav-height);
    left: 0;
    width:100%;
    padding:10px 40px 30px;
    box-sizing:border-box;
    display:block; /* 원래는 nav .menu의 display가 flex였는데 수직정렬을 하기위해서 block으로 바꿈 */
    visibility:hidden;
    opacity:0;
    transform:translate(0, -50px);
    transition:0.4s;
  }
  nav .menu li {
    border-bottom:1px solid var(--color-border);
  }
  nav .menu li:last-child {
    border-bottom:none;
  }
  nav .menu li a {
    padding: 16px 0;
    font-size:14px;
  }
  nav.menuing .shadow {
    visibility:visible;
    opacity:1;
  }
  nav.menuing .contents-bg {
    visibility:visible;
    opacity:1;
    height:232px; /* contents-bg에 visibility가 hidden이고 opacity가 0으로 보이지 않게 하다가 toggler가 클릭되었을때 즉 nav에 .menuing 클래스가 붙었을때 배경이 보이도록 하고 height값을 충분히 늘림*/
  }
  nav.menuing .menu {
    visibility:visible;
    opacity:1;
    transform:translate(0, 0);
  }
  nav.menuing .menu-toggler::before {
    transform: rotate(-40deg);
    /* left:-9px; */ /* 이부분을 굳이 다시 적지 않고 지운것은 어차피 값이 변화가 없기때문에 이전값을 사용하도록(이전에 선언했으니 알아서 적용됨) 하기 위함임 */
  }
  nav.menuing .menu-toggler::after {
    transform:rotate(40deg);
    /* right:-9px; */
  }
}

/* Main */
main {
  overflow-x: hidden; /* 넘치는 것들을 전부 안보이게 해서 가로 스크롤바가 생기지 않도록함 */
}

/* Hero */
.hero {
  background-color:var(--color-section);
}
.hero .inner {
  padding-bottom:110px;
}
.hero h1 {
  background-image:url("../images/hero_ipad_text.png");
  width:221px;
  height:91px;
  position:absolute;
  transform:translate(624px, 235px);
  z-index:1;
}
.hero .figures {
  height:808px;
}
.hero figure {
  transform:translate(74px,-64px);
}
.hero figure img {

}
.hero figure figcaption {

}
.hero figure figcaption .caption-camera {
  width:120px;
  height:84px;
  background-image: url("../images/hero_ipad_caption_camera.png");
  transform:translate(43px, 580px)
}
.hero figure figcaption .caption-chip {
  width:95px;
  height:43px;
  background-image:url("../images/hero_ipad_caption_chip.png");
  transform:translate(589px, 510px);
}
.hero figure figcaption .caption-storage {
  width:80px;
  height:43px;
  background-image:url("../images/hero_ipad_caption_storage.png");
  transform:translate(627px, 631px);
}
.hero h2 {
  width:738px;
  height:145px;
  margin:0 auto;
  background-image:url("../images/hero_headline.png");
}
.hero p.pricing {
  margin-top:40px;
  font-size:24px;
  font-weight:600;
  text-align:center;
}
.hero p.description {
  width: 88%; /* br태그로 줄바꿈 처리를 하지 않고 화면에 글자가 표시될 가로 너비를 생각하며 width값으로 p태그 영역자체를 제한하여 디자인 하는것이 화면이 변할때도 여전히 비율에 맞게 자연스럽게 출력되므로 좋다. */
  margin:18px auto 0;
  font-size:19px;
  text-align:center;
}
.hero .links {
  margin-top:30px;
}

@media (max-width:1000px) {
  .hero .inner {
    padding-bottom: 80px;
  }
  .hero h1 {
    width: 166px;
    height: 68px;
    transform:translate(448px, 165px); /* 줄어든 크기에 맞게 다시 위치 설정 */
  }
  .hero .figures {
    height:584px;
    margin-bottom:14px;
  }
  .hero figure {
    transform:translate(70px, -24px);
  }
  .hero figure img {
    width:540px;
  }
  .hero figure figcaption .caption-camera {
    transform:scale(0.8) translate(-9px, 524px);
  }
  .hero figure figcaption .caption-chip {
    transform:scale(0.8) translate(510px, 422px);
  }
  .hero figure figcaption .caption-storage {
    transform:scale(0.8) translate(556px, 556px);
  }
  .hero h2 {
    width: 515px;
    height: 95px;
  }
  
}
@media (max-width:740px) {
  .hero .inner {
    padding-top:40px;/* padding-top 값만 바꿨으므로 이외의 방향의 padding은 원래의 값으로 잘 들어감. */
  }
  .hero h1 {
    margin: 0 auto 40px; /* 가운데 정렬, 아래 40px 마진 */
    position:static;
    transform:none;
  }
  .hero .figures {
    height: auto;
    margin-bottom:100px;
  }
  .hero figure {
    transform:none;
  }
  .hero figure img {
    width:337px;
  }
  .hero figure figcaption .caption-camera {
    width:180px;
    height:37px;
    background-image: url("../images/hero_ipad_caption_camera_mobile.png");
    transform:scale(1) translate(21px, 368px); /* 태블릿 모드에서 데스크탑에서 쓰던 이미지를 줄여서 사용하게 설정이 되어있었는데 이번에는 새로운 이미지이므로 scale이 원래대로 돌아와야 함 */
  }
  .hero figure figcaption .caption-chip {
    transform:scale(0.8) translate(248px, 42px);
  }
  .hero figure figcaption .caption-storage {
    transform:scale(0.8) translate(288px, 168px);
  }
  .hero h2 {
    width:295px;
    height:185px;
    background-image: url("../images/hero_headline_mobile.png");
  }
  .hero p.pricing {
    font-size:20px;
  }
  .hero p.description {
    width:auto;
    font-size: 17px;
  }
}


/* Power */
.power {
  margin-top:110px;
}
/* Power / Multiple Apps */
.power .multiple-apps h1 {
  width:500px;
  height:280px;
  background-image:url("../images/power_headline.png");
  transform:translate(104px, 0);
}
.power .multiple-apps .figures {
  height:773px;
}
.power .multiple-apps figcaption {
  width:138px;
  height:46px;
  background-image:url("../images/power_multiple_apps_caption.png");
  transform:translate(703px, -47px);
}
/* Power / Arcade */
.power .arcade{
  margin-top:55px;
}
.power .arcade .figures {
  height:600px;
}
.power .arcade figure {
  transform:translate(-347px, -90px);
}
.power .arcade figcaption {
  width:150px;
  height:77px;
  background-image: url("../images/power_arcade_caption.png");
  transform:translate(483px, 653px);
}
/* Power / Create */
.power .create {
  margin-top:55px;
}
.power .create .figures {
  height:772px;
}
.power .create figure {
  transform:translate(-25px, 50px);
}
.power .create figcaption {
  width:142px;
  height:46px;
  background-image:url("../images/power_create_caption.png");
  transform: translate(543px, 908px);
}

@media (max-width:1000px) {
  .power {
    margin-top:80px;
  }
  .power .multiple-apps h1 {
    width: 310px;
    height:180px;
  }
  .power .multiple-apps .figures {
    height:503px; /* 데스크탑에서보다 높이를 줄여서 최대한 적은 공간에 많이 들어갈수있게 함 (모바일이므로) */
  }
  .power .multiple-apps figure {
    transform:translate(71px, 0);
  }
  .power .multiple-apps figure img {
    width:682px;
  }
  .power .multiple-apps figcaption {
    transform:scale(0.8) translate(532px, -58px);
  }
  .power .arcade {
    margin-top:0;
  }
  .power .arcade .figures {
    height:480px;
  }
  .power .arcade figure {
    transform: translate(-182px, -6px);
  }
  .power .arcade figure img {
    width: 676px;
  }
  .power .arcade figcaption {
    transform:scale(0.8) translate(316px, 528px);
  }
  .power .create .figures {
    height:588px;
  }
  .power .create figure {
    transform:translate(4px, -36px);
  }
  .power .create figure img {
    width:820px;
  }
  .power .create figcaption {
    transform: scale(0.8) translate(420px, 747px);
  }
}

@media (max-width: 740px) {
  .power .multiple-apps h1 {
    margin: 0 auto;
    transform: none;
  }
  .power .multiple-apps .figures {
    height:340px;
    margin-top:50px;
  }
  .power .multiple-apps figure {
    transform: translate(20px, 0);
  }
  .power .multiple-apps figure img {
    width:462px;
  }
  .power .multiple-apps figcaption {
    transform:scale(0.8) translate(112px,-45px);
  }
  .power .arcade {
    margin-top: 30px;
  }
  .power .arcade .figures {
    height:auto;
    margin-top:20px;
    order:1; /* flex item인데 html 구조 변경없이 순서를 바꾸는 방법은 order의 숫자를 선언해주는 방법이 있다. 지금 feature안에 있는 infos와 형제로 둘다 flex item인데 figures에 order:1을 주면 숫자가 높으니 뒤에 나온다. 0번이 제일 먼저임 */
  }
  .power .arcade figure {
    transform:translate(20px, 0);
  }
  .power .arcade figure img {
    width:458px;
  }
  .power .arcade figcaption {
    transform:scale(0.8) translate(316px, 368px);
  }
  .power .create .figures {
    height:auto;
    margin-top:20px;
  }
  .power .create figure {
    transform:translate(100px, 0);
  }
  .power .create figure img{
    width:525px;
  }
  .power .create figcaption {
    transform:scale(0.8) translate(254px, 486px);
  }
}

/* Display */
.display{
  margin-top:450px;
}

/* Display / Notes */
.display .notes h1 {
  width:630px;
  height:370px;
  background-image:url("../images/display_headline.png");
  transform:translate(104px, 0);
}
.display .notes .figures {
  height:814px;
  margin-top:26px;
}
.display .notes figcaption {
  width:145px;
  height:45px;
  background-image:url("../images/display_notes_caption.png");
  transform:translate(707px, -16px);
}

/* Display / Shareplay */
.display .shareplay {
  margin-top:55px;
}
.display .shareplay .figures {
  height:630px;
}
.display .shareplay figure {
  transform:translate(-360px, 0);
}
.display .shareplay figcaption {
  width:110px;
  height:38px;
  background-image: url("../images/display_shareplay_caption.png");
  transform:translate(300px, 658px);
}

@media (max-width:1000px) {
  .display {
    margin-top:180px;
  }
  .display .notes h1 {
    width: 400px;
    height: 240px;
    transform:translate(120px,0);
  }
  .display .notes .figures {
    height:530px;
  }
  .display .notes figure {
    transform:translate(80px, -10px);
  }
  .display .notes figure img {
    width:676px;
  }
  .display .notes figcaption {
    transform:scale(0.8) translate(540px, -34px);
  }
  .display .shareplay .figures {
    height: 330px;
  } 
  .display .shareplay figure {
    transform:translate(-178px, 0);
  }
  .display .shareplay figure img {
    width:682px;
  }
  .display .shareplay figcaption {
    transform:scale(0.8) translate(261px, 540px);
  }
}

@media (max-width:740px) {
  .display .notes h1 {
    width:290px;
    height:308px;
    background-image:url("../images/display_headline_mobile.png");
    transform:none;
    margin: 0 auto;
  }
  .display .notes .figures {
    height:auto;
    margin-top:60px;
  }
  .display .notes .figures {
    height: auto;
    margin-top: 60px;
  }
  .display .notes figure {
    transform:translate(20px, 0);
  }
  .display .notes figure img {
    width:458px;
  }
  .display .notes figcaption {
    transform:scale(0.8) translate(220px, -45px);
  }
  .display .shareplay {
    margin-top:30px;
  }
  .display .shareplay .figures {
    height:auto;
    order:1;
  }
  .display .shareplay figure {
    transform: translate(20px, 0);
  }
  .display .shareplay figure img {
    width: 460px;
  }
  .display .shareplay figcaption {
    transform: scale(0.8) translate(261px, 358px);
  }
}

/* Camera */
.camera {
  margin-top:303px;
}
.camera .stage {
  position:relative;
}
.camera .stage h1 {
  width:650px;
  height:450px;
  background-image:url("../images/camera_headline.png");
  transform:translate(-25px, 0);
}
.camera .stage .info {
  position:absolute; /* infos를 사용하지 않고 info만 사용했으니 infos에 정해둔 정렬클래스를 사용할수없고 그래서 직접 배치하는 모습 */
  top:150px;
  right:0;
}
.camera .stage .figures {
  height:770px;
  margin-top:24px;
}
.camera .stage figure {
  transform:translate(90px, 0);
}
.camera .stage video {
  position:absolute;
  top:36px;
  left: 76px;
  -webkit-mask-image: url("../images/camera_video_mask.png");
  mask-image: url("../images/camera_video_mask.png");
}
.camera .stage .controller--play,
.camera .stage .controller--pause {
  user-select: none;
  color:var(--color-link);
  cursor:pointer;
  display:flex;
  align-items:center;
  gap:8px;
  transform: translate(428px, -134px) rotate(-3deg); /* position이 absolute가 아닌데 위치를 조정했으니 원래 위치에는 빈공간이 생길것 또한 위의 동영상은 absolute여서 지금 여기 이요소의 크기만큼만 원래 있던 곳에 빈공간이 생기게됨 */
}
.camera .stage .controller--play:hover,
.camera .stage .controller--pause:hover {
  text-decoration:underline;
}
.camera .stage .controller--play.hide,
.camera .stage .controller--pause.hide {
  display:none;
}
.camera .stage .controller--play img,
.camera .stage .controller--pause img {
  width:20px;
  margin-top:-2px;
}
.camera .stage figcaption {
  width:130px;
  height:110px;
  background-image: url("../images/camera_hardware_caption.png");
  transform:translate(-116px, 383px);
}

/* Camera / Edit */
.camera .edit .figures {
  height:910px;
}
.camera .edit figure {
  transform:translate(20px,0);
}
.camera .edit figcaption {
  width:130px;
  height:47px;
  background-image:url("../images/camera_edit_caption.png");
  transform:translate(27px, 905px);
}

@media (max-width:1000px) {
  .camera {
    margin-top:165px;
  }
  .camera .stage h1 {
    width:405px;
    height:270px;
    transform: translate(0, 0);
  }
  .camera .stage .info {
    top: 0;
  }
  .camera .stage .figures {
    height:500px;
  }
  .camera .stage figure img {
    width: 678px;
  }
  .camera .stage video {
    top: 23px;
    left: 50px;
    transform: scale(0.65);
    transform-origin:0 0; /* transform이 적용되는 기준점을 잡는것으로 원래는 중심에 기준점이 존재하지만 0 0으로 왼쪽 위를 기준점으로 해준것임. */
  }
  .camera .stage .controller--play,
  .camera .stage .controller--pause {
    transform:translate(276px, -88px) rotate(-3deg); /* 이미 들어가있는 각도 조절을 왜 또 아래에서 넣냐 할수있는데 transform이라는 css 속성을 덮어쓰기 하는 중이기 때문에 다시 한번 더 쓰지 않으면 각도가 적용되지 않음 생각해보라 margin: 0 0 0 0;을 해둔상태에서 margin: 9; 이렇게 하면 값이 원래의 값만 되지 않지만 margin-top: 9;이렇게 하면 원하는 곳만 바뀌고 원래의 값이 있지 않은가? 여기도 마찬가지이고 단축속성이므로 다시 써줘야 한다. */
  }
  .camera .stage figcaption {
    transform:scale(0.8) translate(-136px, 306px);
  }
  .camera .edit .figures {
    height:auto; /* height를 기본값인 auto로 해주면 feature안에 묶여있는 infos의 height인 값을 height값으로 갖게 됨 이유는 flex-item은 height값을 stretch하기 때문임. 이와 같이 height가 auto인 상황에 infos의 height를 0으로 하면 당연히 figures도 height가 0이 됨. */
  }
  .camera .edit figure {
    transform:translate(40px, 0);
  }
  .camera .edit figure img {
    width:509px;
  }
  .camera .edit figcaption {
    transform:scale(0.8) translate(27px, 742px);
  }
}

@media (max-width:740px) {
  .camera {
    margin-top:120px;
  }
  .camera .stage h1 {
    width: 304px;
    height:350px;
    background-image: url("../images/camera_headline_mobile.png");
    margin: 0 auto;
  }
  .camera .stage .info {
    position: static;
    margin-top:30px;
  }
  .camera .stage .figures {
    height:auto;
    margin-top:64px;
  }
  .camera .stage figure {
    transform:translate(20px, 0);
  }
  .camera .stage figure img {
    width:450px;
  }
  .camera .stage video {
    transform: scale(0.43);
    top: 15px;
    left:33px;
  }
  .camera .stage .controller--play,
  .camera .stage .controller--pause {
    transform:translate(169px, -51px) rotate(-3deg);
  }
  .camera .stage figcaption {
    width:175px;
    height:43px;
    background-image: url("../images/camera_hardware_caption_mobile.png");
    transform: scale(1) translate(110px, -40px);
  }
  .camera .edit .figures {
    margin-top:30px;
  }
  .camera .edit figure img {
    width:343px;
  }
  .camera .edit  figcaption {
    transform:scale(0.8) translate(27px, 502px);
  }
}



/* Wireless */
.wireless {
margin-top:202px;
}
/* Wireless / Facetime */
.wireless .facetime h1 {
  width:730px;
  height:330px;
  background-image:url("../images/wireless_headline.png");
  transform:translate(104px, 0);
}
.wireless .facetime .figures {
  height:773px;
}
.wireless .facetime figure {
  transform:translate(-68px, 0);
}
.wireless .facetime figcaption {
  width:139px;
  height:46px;
  background-image:url("../images/wireless_facetime_caption.png");
  transform:translate(843px, -49px);
}
/* Wireless / Files */
.wireless .files figure { /* files의 figures에 height값을 이번에는 주지 않은 이유는 바로 앞전에는 요소가 figure뿐이였는데 그마저도 absolute라 hieght를 직접준것이고 이번에는 infos에 height값이 있기 때문에 굳이 주지 않아도 infos의 height값을 height값으로 가지게 됨 */
  transform:translate(34px, -34px);
}
.wireless .files figcaption {
  width:127px;
  height:46px;
  background-image:url("../images/wireless_files_caption.png");
  transform:translate(96px, 639px);
}

@media (max-width:1000px) {
  .wireless {
    margin-top:140px;
  }
  .wireless .facetime h1 {
    width:450px;
    height:200px;
    transform:translate(70px, 0);
  }
  .wireless .facetime .figures {
    height:530px;
  }
  .wireless .facetime figure {
    transform:translate(0, 0);
  }
  .wireless .facetime figure img {
    width: 769px;
  }
  .wireless .facetime figcaption {
    transform:scale(0.8) translate(670px, -60px);
  }
  .wireless .files figure img {
    width:676px;
  }
  .wireless .files figcaption {
    transform: scale(0.8) translate(43px, 520px);
  }
}
@media (max-width: 740px) {
  .wireless {
    margin-top: 120px;
  }
  .wireless .facetime h1 {
    width:312px;
    height:223px;
    background-image:url("../images/wireless_headline_mobile.png");
    transform:none;
    margin:0 auto;
  }
  .wireless .facetime .figures {
    height:auto;
    margin-top:64px;
  }
  .wireless .facetime figure img {
    width: 490px;
  }
  .wireless .facetime figcaption {
    transform: scale(0.8) translate(120px, -45px);
  }
  .wireless .files .figures {
    margin-top:30px;
  }
  .wireless .files figure{
    transform:translate(20px, 0);
  }
  .wireless .files figure img {
    width:450px;
  }
  .wireless .files figcaption {
    transform:scale(0.8) translate(73px, 355px);
  }
}

/* Accessories  */
.accessories {
  margin-top:195px;
}
.accessories h1 {
  width:550px;
  height:343px;
  background-image: url("../images/accessories_headline.png");
  margin: 0 auto;
}
.accessories .figures{
  height: 1021px;
  margin-top:34px;
}
.accessories figure { /* figuers 안의 figcaption 안에 있는 모든 요소들을 absolute 포지션을 갖고 figcaption의 왼쪽위에 배치되도록 하는데 왜 이미지에는 그런게 없는데 배치가 잘되고 있냐? 이유는 이미지와 figcaption이 포함된 figure자체를 figures안에서 이미지의 자리에 맞게 transform의 translate로 이동시키고 그 figure안의 왼쪽 위에 있는 figcaption혹은 figcaption안의 요소들을 거기서 부터 transform의 translate로 이동시켜 위치를 잡기 때문임. */
  transform:translate(-24px, 0);
}
.accessories figcaption .caption-memo {
  width:169px;
  height:41px;
  background-image: url("../images/accessories_caption_memo.png");
  transform:translate(790px, -52px);

}
.accessories figcaption .caption-supports {
width:200px;
height:70px;
background-image:url("../images/accessories_caption_supports.png");
transform:translate(163px, 821px);
}
.accessories .infos {
  flex-direction:row;
  flex-wrap:wrap;
  justify-content:space-around;
}

@media (max-width:1000px) {
  .accessories {
    margin-top: 120px;
  }
  .accessories h1 {
    width: 384px;
    height:243px;
  }
  .accessories .figures {
    height:700px;
  }
  .accessories figure {
    transform:translate(12px, 0);
  }
  .accessories figure img {
    width:712px;
  }
  .accessories figcaption .caption-memo {
    transform:scale(0.8) translate(677px, -60px);
  }
  .accessories figcaption .caption-supports {
    transform: scale(0.8) translate(101px, 650px);
  }
}
@media (max-width:740px) {
  .accessories h1 {
    width:300px;
    height: 190px;
  }
  .accessories .figures {
    height:auto;
    margin-top: 64px;
  }
  .accessories figure img {
    width:380px;
  }
  .accessories figcaption .caption-memo {
    transform:scale(0.8) translate(186px, -58px);
  }
  .accessories figcaption .caption-supports {
    width:160px;
    height:44px;
    transform: scale(1) translate(31px,  335px);
    background-image:url("../images/accessories_caption_supports_mobile.png");
  }
  .accessories .infos {
    margin-top:100px;
  }
}

/* iPadOS */
.ipados {
  margin-top:212px;
}
.ipados h1 {
  width:530px;
  height:400px;
  margin:0 auto;
  background-image:url("../images/ipados_headline.png");
}
.ipados .infos {
  margin-top:44px;
  align-items:flex-end;
}
.ipados .figures {
  height:782px;
  display:flex;
}
.ipados .figures > div {
  flex-grow:1;
  position:relative;
}
.ipados .figure-split-view figure {
  transform:translate(-205px, -312px);
}
.ipados .figure-split-view figcaption {
  width:163px;
  height:53px;
  background-image:url("../images/ipados_split_view_caption.png");
  transform:translate(200px, -38px);
}
.ipados .figure-widgets figure {
  transform:translate(237px, 43px);
}
.ipados .figure-widgets figcaption {
  width:161px;
  height:46px;
  background-image:url("../images/ipados_widgets_caption.png");
  transform:translate(257px, 497px);
}
.ipados .figure-quick-note figure {
  transform:translate(-625px, 232px);
}
.ipados .figure-quick-note figcaption {
  width:82px;
  height:97px;
  background-image:url("../images/ipados_quick_note_caption.png");
  transform:translate(511px, 470px);
}

@media (max-width:1000px) {
  .ipados {
    margin-top: 100px;
  }
  .ipados h1 {
    width:357px;
    height: 274px;
    margin: 0;
  }
  .ipados .infos {
    margin-top: -98px;
  }
  .ipados .figures {
    height:520px;
  }
  .ipados .figure-split-view figure {
    transform: translate(-17px, -187px);
  }
  .ipados .figure-split-view figure img {
    width: 441px;
  }
  .ipados .figure-split-view figcaption {
    transform:scale(0.8) translate(30px, -50px);
  }
  .ipados .figure-widgets figure {
    transform:translate(180px, 3px);
  }
  .ipados .figure-widgets figure img {
    width: 441px;
  }
  .ipados .figure-widgets figcaption {
    transform: scale(0.8) translate(152px, 345px);
  }
  .ipados .figure-quick-note figure {
    transform:translate(-346px, 119px);
  }
  .ipados .figure-quick-note figure img {
    width: 333px;
  }
  .ipados .figure-quick-note figcaption {
    transform: scale(0.8) translate(350px, 310px);
  }
}
@media (max-width: 740px) {
  .ipados h1 {
    width: 300px;
    height:227px;
    margin: 0 auto;
  }
  .ipados .infos {
    margin-top: 30px;
    text-align:center;
  }
  .ipados .figures {
    display:block;
    height:auto;
  }
  .ipados .figures > div {
    display:flex;
    justify-content: center;
  }
  .ipados .figure-split-view figure {
    transform:translate(64px, 55px); /* 이미지를 원하는 위치로 이동 이유인 즉슨 이미지의 크기도 달라지고 figure도 flex item으로 주축 가운데에 정렬이 되어있으므로 새로운 값이 필요. */
  }
  .ipados .figure-split-view figure img {
    width: 370px; /* 기존의 이미지의 크기를 조금 줄임 */
  }
  .ipados .figure-split-view figcaption {
    transform: scale(0.8) translate(39px, -55px); /* 이미지가 줄었으므로 날개설명도 그에 맞게 0.8배 만큼 줄었고 figure가 flex item이 되며 주축 가운데에 정렬이 되는것으로 바뀌었으니 원하는데 위치시키기 위해서 새로운 값을 translate에 넣음 */
  }
  .ipados .figure-widgets figure {
    transform: translate(-19px, 34px); 
  }
  .ipados .figure-widgets figure img {
    width: 375px;
  }
  .ipados .figure-widgets figcaption {
    transform:scale(0.8) translate(252px, 287px);
  }
  .ipados .figure-quick-note figure {
    transform:translate(35px, 46px);
  }
  .ipados .figure-quick-note figure img {
    width: 283px;
  }
  .ipados .figure-quick-note figcaption {
    width: 76px;
    height:88px;
    background-image: url("../images/ipados_quick_note_caption_mobile.png");
    transform:scale(1) translate(-65px, 250px);
  }
}

/* Apps */
.apps {
  margin-top:368px;
}
.apps h1 {
  width:500px;
  height:264px;
  background-image:url("../images/apps_headline.png");
  transform:translate(17px, 0);
}
.apps .infos {
  margin:36px 0 0 82px;
}
.apps .figures {
  display:flex;
  height:788px;
}
.apps .figures > div {
  flex-grow:1;
  position:relative;
}
.apps .figure-masterclass figure {
  transform:translate(578px, -431px);
}
.apps .figure-masterclass figcaption {
  width:100px;
  height:25px;
  background-image:url("../images/apps_masterclass_caption.png");
  transform:translate(26px, 690px);
}
.apps .figure-adobe figure {
  transform:translate(-515px, 85px);
}
.apps .figure-adobe figcaption {
  width:105px;
  height:24px;
  background-image:url("../images/apps_adobe_caption.png");
  transform:translate(544px, 514px);
}
.apps .figure-fantasian figure {
  transform:translate(103px, 318px);
}
.apps .figure-fantasian figcaption {
  width:74px;
  height:22px;
  background-image:url("../images/apps_fantasian_caption.png");
  transform:translate(24px, 483px);
}
.apps .figure-books figure {
  transform:translate(-133px, -150px);
}
.apps .figure-books figcaption{
  width:50px;
  height:27px;
  background-image:url("../images/apps_books_caption.png");
  transform:translate(397px, 707px);
}
.apps .figure-goodnotes figure {
  transform:translate(-93px, 68px);
}
.apps .figure-goodnotes figcaption{
  width:99px;
  height:26px;
  background-image:url("../images/apps_goodnotes_caption.png");
  transform:translate(24px, 690px);
}

@media (max-width: 1000px) {
  .apps {
    margin-top: 120px;
  }
  .apps h1 {
    width: 390px;
    height:208px;
    transform:none;
  }
  .apps .infos {
    margin-left: 0;
    text-align:center;
  }
  .apps .info {
    max-width: 404px;
  }
  .apps .figures {
    height: 450px;
  }
  .apps .figure-masterclass figure {
    transform: translate(438px, -264px);
  }
  .apps .figure-masterclass figure img {
    width: 330px;
  }
  .apps .figure-masterclass figcaption {
    transform: scale(0.8) translate(6px, 480px);
  }
  .apps .figure-adobe figure{
    transform:translate(-203px, 20px);
  } 
  .apps .figure-adobe figure img {
    width: 438px;
  }
  .apps .figure-adobe figcaption {
    transform: scale(0.8) translate(324px, 355px);
  }
  .apps .figure-fantasian figure {
    transform: translate(-40px, 160px);
  }
  .apps .figure-fantasian figure img {
    width: 433px;
  }
  .apps .figure-fantasian figcaption {
    transform: scale(0.8) translate(14px, 339px);
  }
  .apps .figure-books figure {
    transform: translate(42px, -94px);
  }
  .apps .figure-books figure img {
    width: 330px;
  }
  .apps .figure-books figcaption {
    transform: scale(0.8) translate(252px, 493px);
  }
  .apps .figure-goodnotes figure {
    transform:translate(3px, 28px);
  }
  .apps .figure-goodnotes figure img {
    width: 346px;
  }
  .apps .figure-goodnotes figcaption {
    transform:scale(0.8) translate(5px, 483px);
  }
}
@media (max-width: 740px) {
  .apps h1 {
    width: 320px;
    height: 169px;
    margin: 0 auto;
  }
  .apps .info {
    max-width: none;
  }
  .apps .figures {
    display: block; /* 원래 flex를 줘서 자식요소들을 수평로 놓고 원하는 곳으로 위치시켰는데 이제는 block으로 해서 자식요소들을 수직으로 정렬하게 되고 거기서 원하는 위치로 이동시켜야함 */
    height: auto;
  }
  .apps .figures > div {
    display:flex; /* figure을 div의 수평 중앙에 위치시켜서 사실상 사진이 중앙에 위치하도록 함 그후 원하는 위치로 translate를 통해 배치 */
    justify-content:center;
    height: 240px;
  }
  .apps .figure-masterclass figure {
    transform: translate(140px, 40px);
  }
  .apps .figure-masterclass figure img {
    width: 270px;
  }
  .apps .figure-masterclass figcaption {
    transform: scale(0.8) translate(29px, 400px);
  }
  .apps .figure-adobe figure {
    transform: translate(-154px, -126px);
  }
  .apps .figure-adobe figure img {
    width: 358px;
  }
  .apps .figure-adobe figcaption {
    transform: scale(0.8) translate(233px, 295px);
  }
  .apps .figure-fantasian figure {
    transform: translate(19px, -82px);
  }
  .apps .figure-fantasian figure img {
    width: 358px;
  }
  .apps .figure-fantasian figcaption {
    transform: scale(0.8) translate(24px, 282px);
  }
  .apps .figure-books figure {
    transform: translate(-100px, -40px);
  }
  .apps .figure-books figure img {
    width: 270px;
  }
  .apps .figure-books figcaption {
    transform: scale(0.8) translate(197px, 407px);
  }
  .apps .figure-goodnotes figure {
    transform: translate(132px, -110px);
  }
  .apps .figure-goodnotes figure img {
    width: 286px;
  }
  .apps .figure-goodnotes figcaption {
    transform: scale(0.8) translate(24px, -37px);
  }
}

/* Privacy */
.privacy {
  margin-top:238px
}
.privacy h1{
  width:482px;
  height:237px;
  background-image:url("../images/privacy_headline.png");
  margin-left:auto; /* 요소의 왼쪽 여백이 자동으로 채워지게함 */
  position:relative;
  z-index:1; /* figures의 이미지에 깔리는 현상을 해결하려고 position과 z-index값을 줌 */
  transform:translate(57px,0);
}
.privacy .infos {
  margin-top:38px;
  align-items: flex-end;/* 수평의 끝쪽으로 정렬하기때문에 justify-content를 생각할수도있지만 지금 infos는 위에서 정해둔 flex-direction에 의해 column을 주축으로 갖고있다. 그렇기 때문에 교차축을 관장하는 align-item혹은 align-content를 사용해야 하는데 여기서 flex-item은 하나뿐이라. align-items가 사용됨 */
}
.privacy figure {
  transform:translate(-215px, -500px);
}
.privacy figcaption .caption-apple-id {
  width:170px;
  height:26px;
  background-image:url("../images/privacy_caption_apple_id.png");
  transform:translate(195px, -13px);
}
.privacy figcaption .caption-touch-id {
  width:150px;
  height:31px;
  background-image:url("../images/privacy_caption_touch_id.png");
  transform:translate(533px, 485px);
}

@media (max-width: 1000px) {
  .privacy {
    margin-top:120px;
  }
  .privacy h1 {
    width: 368px;
    height: 182px;
    transform: translate(70px, 0);
  }
  .privacy .infos {
    margin-top: 24px;
  }
  .privacy figure {
    transform:translate(-18px, -440px);
  }
  .privacy figure img {
    width:441px;
  }
  .privacy figcaption .caption-apple-id {
    transform: scale(0.8) translate(-22px, -18px);
  }
  .privacy figcaption .caption-touch-id {
    transform: scale(0.8) translate(293px, 339px);
  }
}

@media (max-width:740px) {
  .privacy h1 {
    width: 277px;
    height:136px;
    transform:none;
    margin: 0 auto;
  }
  .privacy .figures {
    margin-top: 30px;
  }
  .privacy figure {
    transform: translate(20px, 0);
  }
}

/* Accessibility */
.accessibility {
  margin: 266px 0 170px 0;
}
.accessibility h1 { /* 위치를 왼쪽 혹은 가운데 혹은 오른쪽등으로 조정해주지 않아도 그자체로 원하는 위치임 */
  width:384px;
  height:270px;
  background-image:url("../images/accessibility_headline.png");
}
.accessibility .infos {/* infos위에 공간을 가진 블록요소가 있으니 infos는 h1아래에 오게 되고 위에 여백만 주면 위치를 왼쪽 혹은 가운데 혹은 오른쪽등으로 조정해주지 않아도 원하는 위치임 */
  margin-top:20px;
}
.accessibility figure {
  transform:translate(470px, -620px);
}

@media (max-width: 1000px) {
  .accessibility {
    margin-top: 86px;
    margin-bottom: 120px;
  }
  .accessibility h1 {
    width: 287px;
    height:205px;
  }
  .accessibility .info {
    max-width: 346px;
  }
  .accessibility figure {
    transform:translate(401px, -504px);
  }
  .accessibility figure img {
    width: 329px;
  }
}
@media (max-width: 740px) {
  .accessibility {
    margin-bottom: 50px;
  }
  .accessibility h1 {
    height:165px;
    margin:0 auto;
  }
  .accessibility .info {
    max-width: none;
  }
  .accessibility .figures {
    margin-top: 30px;
  }
  .accessibility figure {
    transform:translate(20px, 0);
  }
}

/* AR */
.ar {
  background-color:var(--color-section);
  padding:20px 20px 0;
}
.ar .whitebox {
  padding-bottom:0;
}
.ar .inner {
  display:flex;

}
.ar .inner > div {
  max-width:410px;
  margin-top:60px;
  margin-right:90px;
}

@media (max-width: 1000px) {
  .ar .image {
    width: 258px;
  }
}
@media (max-width: 740px){
  .ar .inner{
    flex-direction: column;
    align-items:center;
  }
  .ar .inner > div {
    max-width: none;
    margin: 0 0 30px;
    text-align:center;
  }
  .ar .icon {
    margin: 0 auto 20px;
  } /* h1 태그는 굳이 가운데 정렬을 해주지 않는 이유는 h1의 부모 div에 width는 없으므로 (왜 width값이 전체를 갖지 않느냐? inner의 display가 flex라 그안의 div는 flex item이 되게 되지만 height는 stretch 되어도 width로는 stretch 되지 않으므로 inner의 자식이자 h1태그의 부모인 div는 자식콘텐츠의 크기에 맞춰 width값을 갖게 되고 자식콘텐츠중 가장 큰 width값을 가지는 h1의 값을 width값으로 갖게 되므로 h1태그는 항상 전체 width를 차지하게 되고 이는 중앙정렬이 된 효과를 냄 만약 div요소에 width값이 있다면 h1에도 text-align:center값이 도움을 주겠지만 그런상태가 아니라면 h1은 어차피 가운데에 있으므로 text-align:center가 있으나 없으나 다름이 없음 또한 화면의 width가 줄어들어 h1 태그가 width값이 가장 큰 자식콘텐츠가 아니게 될때 text-align:center의 도움을 받아 가운데에 정렬되게 됨. */
 }
/* Environment */
.environment {
  padding: 20px 20px 0;
  background-color:var(--color-section);
  text-align:center;
}
.environment .icon {
  margin: 0 auto 20px; /* 공통속성으로 만들어놨었던 whitebox 안의 icon클래스를 가진 요소의 margin-bottom:20px이 margin값이 우선순위를 가지는 곳에서 선언되어서 덮어쓰기 되어서 적용이 안되게 되었으므로 직접 여기서 다시 주면 됨 그러나 이외의 방법으로 margin-left와 margin-right에 각각 auto값을 주면 margin-bottom의 값을 덮어쓰기 하지 않으므로 원하는대로 여백이 들어갈수있음 */
}
.environment h1 {
  color:#03A10E;
}

@media (max-width:1000px) {
  .environment p br {
    display: none; /* br태그 적용을 없애고 싶을때 이와 같이 할수있다. */
  }
}

/* Accessory Shop */
.accessory-shop {
  background-color: var(--color-section);
  text-align:center; /* 아래에서 flex와 align-item:center로 가운데 정렬을 했더라도 여기의 text-align:center는 여전히 필요한데 이유는 요소가 가운데 정렬이 되더라도 줄바꿈한 글씨가 요소안에서 가운데 정렬을 해야하기 때문임. */
}
.accessory-shop .whitebox {
  padding-bottom:0; /* 위에서 공통속성으로 whitebox에 padding값중 bottom값도 100px이 들어가있는데 해당값을 사용하지 않기위해 새로 만들어 0값을 덮어쓰움 */
}
.accessory-shop .inner {
  display:flex; /* flex로 inner안의 요소들을 가운데 정렬하는 이유는 다른것은 가운데 정렬이 문제없이 되는데 아래의 이미지가 inner보다 큰 width값을 갖으므로 margin: 0 auto를 통한 가운데 정렬이 안되고 그렇기 때문에 flex-item으로 만들어서 정렬을 시키는것. */
  flex-direction: column;
  align-items:center;
}
.accessory-shop img {
  margin-top:50px;
}

@media (max-width: 1000px) {
  .accessory-shop img {
    width: 960px;
  }
}

/* Trade */
.trade {
  padding:20px 20px 0;
  background-color:var(--color-section);
  text-align: center;
}

@media (max-width: 1000px) {
  .trede p br {
    display:none;
  }
}

/* Compare */
.compare {
  padding:20px 20px 0;
  background-color:var(--color-section);
  text-align:center;
}
.compare .items {
  display:flex;
  justify-content:space-around;
  max-width:940px;
  margin:68px auto 74px;
}
.compare .item {
  width:190px;
  padding-bottom:34px;
  border-bottom:1px solid var(--color-border);

}
.compare .item .thumbnail {
  height:214px;
  margin-bottom:22px;
  display:flex;
  justify-content: center;
  align-items: flex-end;
}
.compare .item ul.colors {
  margin-bottom:30px;
  display:flex;
  justify-content: center;
  gap:6px;
}
.compare .item ul.colors li {
  width:12px;
  height:12px;
  border-radius:50%;
  background-color:var(--color-font-lightgray);
  box-shadow:inset 1px 1px 3px rgba(0,0,0, 0.1); /* 그림자는 바깥쪽에 생기지만 inset을 앞에 입력해주면 요소의 안쪽에 생기도록 할수도있다. */
}
.compare .item h3.name {
  margin-bottom:4px;
  font-size:22px;

}
.compare .item .tagline {
  margin-bottom:20px;
  font-size:16px;
}
.compare .item .price {
  margin-bottom:10px;
  font-size:14px;
}
.compare .item .btn {
  margin:0 auto 14px;
}
.compare .item a.link {
  font-size:14px;
}

@media (max-width: 1000px) {
  .compare .items {
    flex-wrap :wrap;
    justify-content: space-between;
    max-width: 500px;
    margin: 68px auto 34px;
  }
}

@media (max-width: 740px) {
  .compare .whitebox {
    max-width: 430px;
  }
  .compare .items {
    max-width: 190px;
  }
  .compare .item {
    border-bottom: none;
  }
  .compare .links {
    padding-top: 40px;
    border-top: 1px solid var(--color-border);
  }
  .compare a.link {
    margin-top: 0;
  }
}

/* Footer */
footer {
  background-color: var(--color-section);
}
/* Footer / Buy-info */
footer .buy-info{ 
  padding:76px 0;
  display:flex;
  justify-content: space-around;
  gap:20px;
  text-align: center;
}
footer .buy-info .icon {
  width:56px;
  height:56px;
  margin:0 auto 10px;
}
footer .buy-info h3 {
  margin-bottom:8px;
  font-size:18px;
  font-weight:600;
}
footer .buy-info p {
  margin-bottom:12px;
  font-size: 14px;
}
footer .buy-info a.link {
  font-size:14px;
}
/* Footer / Warning */
footer .warning {
  padding:18px 0 10px;
  border-top:1px solid var(--color-border);
  border-bottom:1px solid var(--color-border);
}
footer .warning ol {
  list-style:decimal;
  padding-left:16px; /* 앞에 숫자가 붙는걸 계산해서 그만큼의 여백을 만들어둠 안만들면 앞으로 삐져나올것. */
}
footer .warning li {
  margin-bottom:10px;
  font-size:11px;
  line-height:1.5;
  color:var(--color-font-darkgray);
}
/* Footer / Breadcrumbs */
footer .breadcrumbs {
  display:flex;
  align-items:center;
  gap:30px;
  margin:20px 0;
}
footer .breadcrumbs a {
  font-size:12px;
  color:var(--color-font-darkgray);
  position:relative;
}
footer .breadcrumbs a.apple-logo {
  width:16px;
  height:16px;
  background-image:url("../images/path_apple.svg");
}
footer .breadcrumbs a:hover {
  text-decoration: underline;
}
footer .breadcrumbs a::after {
  content: "";
  width:8px;
  height:18px;
  background-image: url("../images/path_div.svg");
  position:absolute;
  top:0;
  bottom:0;
  right:-18px;
  margin: auto;
}
footer .breadcrumbs a:last-child::after {
  display:none; /* 마지막에도 들어가면 안됨 요소 사이사이에만 들어가야 하므로 직접 안보이게 해줌 */
}
/* Footer / NAvigations */
footer .navigations {
  margin-bottom: 40px;
  display:flex;
  flex-direction: column;
  height:344px;
  flex-wrap: wrap; /* 이와 같이 높이를 정해두고 줄바꿈되도록 해서 위치를 맞출수있고 심지어 지금은 원하는 대로 들어가지만 이것은 계산된 것임 하여튼 들어갈 공간(height)를 정해두고 줄바꿈이 가능하게 하여 두개 혹은 세개의 요소가 한 줄에 적절히 들어갈수있도록 할수있음 물론 내가 내 앱을 만들때에도 이렇게 만들수있음 일단 제일 진 요소를 기준으로 height를 정해두고 줄바꿈이 가능하게 한 이후에 요소들이 공간이 있는곳에 적절히 들어가고 만약 어떤 요소에서 줄바꿈을 강제로 하고싶다면 그냥 밑으로 padding값을 주면 height와 wrap값때문에 줄처리 되도록 해서 원하는 대로 사실상 배치가 가능함 */
  align-content:space-between;
}
footer .navigations .map {
  margin-top:24px;
}
footer .navigations .map h3{
  font-size:12px;
  font-weight:600;/* map의 제목이므로 두껍게 해서 눈에 띄게함 */
}
footer .navigations .map h3 .icon {
  display: none;
}
footer .navigations .map:nth-child(6) {
  padding-bottom:100px;
}
footer .navigations .map li {
  margin-top: 12px; /* 각각의 li사이의 공간을 이렇게 만듦 */
  font-size:12px;
}
footer .navigations .map li a {
  color:var(--color-font-darkgray) /* 각각의 li들은 모두 a인데 그들의 색갈을 제목보다 조금 연하게 만듦 */
}
footer .navigations .map li a:hover {
  text-decoration: underline;
}
footer .how-to-shop {
  font-size:12px;
  line-height:1.4;
  color:var(--color-font-darkgray);
}
footer .how-to-shop a{
  color:var(--color-link);
}
footer .how-to-shop a:hover {
  text-decoration: underline;
}
footer .legal {
  margin-top:10px;
  padding:10px 0 40px;
  border-top:1px solid var(--color-border);
  display:flex;
  gap:50px;
  font-size:12px;
  color:var(--color-font-darkgray);
}
footer .legal ul {
  flex-grow:1;
  display:flex;
  gap:21px;
}
footer .legal ul li {
  position:relative;
}
footer .legal ul li::after {
  content:"|";
  position:absolute;
  right:-11px;
  color:var(--color-border);
}
footer .legal ul li:last-child:after {
  display:none;
}
footer .legal ul li:hover a {
  text-decoration: underline;
}

@media (max-width:1000px) {
  footer .inner {
    max-width: none;
  }
  footer .legal {
    flex-direction: column;
    gap : 10px;
    padding: 10px 0 30px;
  }
  footer .legal .locale {
    margin-top: 14px;
  }
}
@media (max-width:740px) {
  footer .buy-info {
    flex-wrap: wrap;
  }
  footer .navigations {
    height: auto;
    display:block;
  }
  footer .navigations .map {
    margin-top: 0;
    border-bottom: 1px solid var(--color-border);
  }
  footer .navigations .map:nth-child(6) {
    padding-bottom: 0;
  }
  footer .navigations .map h3 {
    padding: 12px 0;
    font-weight: 400;
    cursor:pointer;
    display:flex;
  }
  footer .navigations .map:hover h3 {
    font-weight: 600;
  }
  footer .navigations .map h3 .text {
    flex-grow:1; /* 아이콘과 함께 flex item인데 아이콘을 왼쪽 끝으로 보내야 하므로 flex-grow를 1로 하여 .text의 width를 늘려서 아이콘을 오른쪽에 배치되도록 한다. */
  }
  footer .navigations .map h3 .icon {
    display:block;
    padding: 0 10px;
    color: var(--color-font-darkgray);
  }
  footer .navigations .map ul {
    height: 0;
    overflow: hidden;
    transition: 
      transform .6s,
      opacity .4s;
    transform: translate(0px, -20px); /* 약간 위에 배치해놨다가 누르면 내려오는 애니매이션을 하기위한 세팅 */
    opacity: 0;
  }
  footer .navigations .map.active ul {
    height: auto;
    overflow:visible; /* 기본값으로 돌려놓는것. */
    padding: 6px 0 18px;
    transform:translate(0, 0); /* 원래 약간 위에 뒀던걸 원래의 위치로 돌아오게 해서 애니메이션 처리를 함 */
    opacity: 1;
  }
  footer .navigations .map h3 .icon {
    transform: scale(1.2) rotate(45deg);
  }
  footer .legal ul {
    flex-wrap: wrap;
    gap: 6px 21px; /* margin이나 padding처럼 상하좌우에 각각 gap값을 줄수있다. */
  }
}
/* height값을 0으로 하지 않았을때에는 auto이므로 자동으로 ul안에 있는 콘텐츠의 height를 값으로 가질텐데 height값을 0으로 주면서 사실상 자식요소들이 밖으로 넘쳐흐르는 현상이 발생한것임 이때 overflow:hidden값을 ul에 주어서 애초에 li들이 보이지 않게 해줄수있음 또한 oveflow를 하지 않았을때 ul의 height는 분명히 0인데 ul안의 li의 margin이 map의 크기를 키우는 형상이 발생함 이는 마진 상쇄라는 현상때문이고 이는 부모에서 border등으로 막아줄수있음 실제로 ul에 border-top을 해서 막아봤음 */

/* a요소를 클릭하기 위한 충분한 공간을 만들기 위해서 padding을 사용 또한 inline요소에는 padding, margin이 좌우로만 되니(인라인 요소의 width나 height는 좌우로도 늘릴수없음) display를 block으로 해줌 */





/* Popup */
.popup {
  width:100%; /* 블록요소인데도 불구하고 자동으로 width가 100%가 안되는 이유는 position이 fixed여서 흐름에서 벗어나서 부모를 갖지 않기때문. */
  position:fixed;
  top:calc(50% - 290px);
  margin:0 auto;
  z-index:9;
}
.popup .shadow {
  position:fixed;
  top:0;
  left:0;
  width:100%;
  height:100vh;
  background-color:var(--color-shadow);
  visibility: visible;
  opacity: 1;
  transition: 0.4s;
}
.popup.clear .shadow {
  visibility:hidden;
  opacity:0;
}
.popup.hide {
  visibility: hidden;
  opacity:0;
  transition:0.6s;
}
.popup .popup-inner {
  margin:0 auto;
  padding: 30px;
}
.popup .popup-inner .popup-area {
  background-color:#fff;
  padding:20px;
  border: 1px solid var(--color-link-focus);
  width:300px;
  height: 370px;
  margin:0 auto;
  position:relative;
  border-radius: 40px;
  box-sizing:border-box;
  /* box-shadow:5px 1px 3px rgba(0,0,0, 0.1) */
}
.popup .popup-area .pop-main {
  margin:20px 0 15px 0;
  font-size:40px;
  font-weight:700;
  color:#81B9F1;
  text-align:center;
}
.popup .popup-area .line {
  /* margin-top:15px; */
  width:80%;
  border:1px solid rgb(229, 229, 229);
  margin:0 auto;
}
.popup .popup-area .text {
  width:100%;
  margin-top:40px;
  text-align:center;
  color:var(--color-font-darkgray);
  line-height: 24px;
}
.popup .popup-area .text span {
  text-decoration: underline;
}
.popup .popup-area .check {
  width:120px;
  height:35px;
  position:relative;
  margin:40px auto 34px;
  cursor:pointer;
  background-color:#0071E3;
  color:#fff;
  display:flex;
  align-items:center;
  justify-content: center;
  border-radius:25px;
  transition:background-color 0.4s, border 0s 0.16s;
}
.popup .popup-area .check:hover {
  background-color:#fff;
  color: #0071E3;
  border:2px solid #0071E3;
  box-sizing:border-box;
}
.popup .popup-area .line.line-small {
  width:32%;
}
.popup .popup-area .popup-apple-logo {
  width:200px;
  height:35px;
  background-image:url("../images/lightnin-color.png");
  position:absolute;
  left:15%;
  bottom:9px;
}




@keyframes sprite-icon {
  /* 1~10 */
  0.00% { background-position: 0 0; }
  1.67% { background-position: -100px 0; }
  3.33% { background-position: -200px 0; }
  5.00% { background-position: -300px 0; }
  6.67% { background-position: -400px 0; }
  8.33% { background-position: -500px 0; }
  10.00% { background-position: 0 -100px; }
  11.67% { background-position: -100px -100px; }
  13.33% { background-position: -200px -100px; }
  15.00% { background-position: -300px -100px; }

  /* 11~20 */
  16.67% { background-position: -400px -100px; }
  18.33% { background-position: -500px -100px; }
  20.00% { background-position: 0 -200px; }
  21.67% { background-position: -100px -200px; }
  23.33% { background-position: -200px -200px; }
  25.00% { background-position: -300px -200px; }
  26.67% { background-position: -400px -200px; }
  28.33% { background-position: -500px -200px; }
  30.00% { background-position: 0 -300px; }
  31.67% { background-position: -100px -300px; }

  /* 21~30 */
  33.33% { background-position: -200px -300px; }
  35.00% { background-position: -300px -300px; }
  36.67% { background-position: -400px -300px; }
  38.33% { background-position: -500px -300px; }
  40.00% { background-position: 0 -400px; }
  41.67% { background-position: -100px -400px; }
  43.33% { background-position: -200px -400px; }
  45.00% { background-position: -300px -400px; }
  46.67% { background-position: -400px -400px; }
  48.33% { background-position: -500px -400px; }

  /* 31~40 */
  50.00% { background-position: 0 -500px; }
  51.67% { background-position: -100px -500px; }
  53.33% { background-position: -200px -500px; }
  55.00% { background-position: -300px -500px; }
  56.67% { background-position: -400px -500px; }
  58.33% { background-position: -500px -500px; }
  60.00% { background-position: 0 -600px; }
  61.67% { background-position: -100px -600px; }
  63.33% { background-position: -200px -600px; }
  65.00% { background-position: -300px -600px; }

  /* 41~50 */
  66.67% { background-position: -400px -600px; }
  68.33% { background-position: -500px -600px; }
  70.00% { background-position: 0 -700px; }
  71.67% { background-position: -100px -700px; }
  73.33% { background-position: -200px -700px; }
  75.00% { background-position: -300px -700px; }
  76.67% { background-position: -400px -700px; }
  78.33% { background-position: -500px -700px; }
  80.00% { background-position: 0 -800px; }
  81.67% { background-position: -100px -800px; }

  /* 51~60 */
  83.33% { background-position: -200px -800px; }
  85.00% { background-position: -300px -800px; }
  86.67% { background-position: -400px -800px; }
  88.33% { background-position: -500px -800px; }
  90.00% { background-position: 0 -900px; }
  91.67% { background-position: -100px -900px; }
  93.33% { background-position: -200px -900px; }
  95.00% { background-position: -300px -900px; }
  96.67% { background-position: -400px -900px; }
  98.33% { background-position: -500px -900px; }
}
